const fs = require("fs");
const path = require("path");
const UTIL = require("../util.js");

const ParsedValue = require("./value.js");

class BaseGenerator {
	constructor(file, data) {
		this.file = file;
		this.data = data;

		this.name = data.identifier.text;

		this.shaders = [];
		this.codes = [];
		this.functions = [];
		this.property = [];

		this.properties = new Map();
		for (let item of this.data.block.items) {
			if (item.type === "shader") {
				this.shaders.push(item);
			}else if (item.type === "cpp") {
				this.codes.push(item);
			}else if (item.type === "function") {
				this.functions.push(item);
			}else if (item.type === "property") {
				this.property.push(item);
			}
		}
	}



	code(scope) {
		let code = "";
		for (let item of this.codes) {
			if (item.visibility == scope)
				code += item.code.text;
		}

		return UTIL.RemoveFrontWhitespace(code);
	}

	output(opts) {
		let template = opts.template;
		let outputFile = opts.output;
		let data = opts.data;
		let context = opts.context;
		let version = require("../../package.json").version;

		let realTemplatePath = path.join(__dirname, "../template/", template);
		let raw = fs.readFileSync(realTemplatePath, "utf8");
		
		let moduleName = this.file.module;
		const PLUGIN_NAME = this.file.plugin;
		const MODULE_NAME = moduleName;
		const SCOPE = moduleName.toUpperCase() + "_API";
		const CLASS_NAME = moduleName + data.name;
		const NAME_NO_PREFIX = this.nameWithoutPrefix;
		const NAME = data.name;
		const instance = this;

		const PUBLIC_CODE = this.code("Public");
		const PRIVATE_CODE = this.code("Private");

		let generated = (() => {
			return eval("`" + raw + "`");
		})();

		generated = `/*
* This file was generated by Shadeup.
* Template: ${template}
* Shadeup Version: ${version}
* Shader Name: ${data.name}
*/

${generated}`;

		let realOutFile = path.join(this.file.outputDir, outputFile);
		fs.mkdirSync(path.dirname(realOutFile), {recursive: true});
		fs.writeFileSync(realOutFile, generated);

		console.log("Successfully generated", realOutFile);
	}

	prop(name, def) {
		if (this.properties.has(name)) {
			return this.properties.get(name).value();
		}else{
			return def;
		}
	}

	error(context, message) {
		this.file.error(context, message);
		throw new Error("Exiting");
	}

	checkRoot(key, type, msg) {
		let r = new ParsedValue(this.file, {location: this.data.block.location, value: this.data.block});
		return this.checkKey(r, key, type, msg);
	}

	checkKey(base, key, type, msg) {
		let real = base.value();
		if (!real[key]) {
			this.error(base.data || base, msg);
		}
		
		if (typeof type === "string") {
			if (real[key].type !== type) {
				this.error(real[key].data, msg + " (wrong type)");
			}
		}else if (Array.isArray(type)) {
			if (!type.includes(real[key].type)) {
				this.error(real[key].data, msg + " (wrong type)");
			}
		}

		return true;
	}

	includeLib() {
		this.output({
			context: this.data,
			template: "lib/ShadeupLib.h",
			output: `Source/${this.file.module}/Public/ShadeupLib.h`,
			data: this
		});

		this.output({
			context: this.data,
			template: "lib/ShadeupLib.cpp",
			output: `Source/${this.file.module}/Private/ShadeupLib.cpp`,
			data: this
		});
	}
	
	verify() {
		if (this.data.inherits) {
			for (let i of this.data.inherits.items.items) {
				let name = i.text;
				if (!this.file.definitions.has(name)) {
					this.error(i, `Trying to inherit an undefined parent "${name}"`);
				}
			}

			for (let i of this.data.inherits.items.items) {
				let name = i.text;
				let definition = this.file.definitions.get(name);
				this.shaders = [...definition.shaders, ...this.shaders];
				this.functions = [...definition.functions, ...this.functions];
				this.property = [...definition.property, ...this.property];
			}
		}

		for (let prop of this.property) {
			let name = prop.identifier.text;
			let value = new ParsedValue(this.file, prop.value);
			if (!this.properties.has(name)) {
				if (prop.operator.text == "=" || prop.operator.text == "+=") {
					this.properties.set(name, value);
				}
			}else{
				let baseValue = this.properties.get(name);
				if (prop.operator.text == "=") {
					this.properties.set(name, value);
				}else if (prop.operator.text == "+=") {
					let baseType = baseValue.type;

					if (baseType == "array") {
						if (value.type == "array") {
							baseValue.data.value.values = [...baseValue.data.value.values, ...value.data.value.values];
						}else if (value.type == "number") {
							baseValue.data.value.values = [...baseValue.data.value.values, value.data];
						}else if (value.type == "string") {
							baseValue.data.value.values = [...baseValue.data.value.values, value.data];
						}else if (value.type == "boolean") {
							baseValue.data.value.values = [...baseValue.data.value.values, value.data];
						}else{
							this.error(prop.operator, `Can't add a value of type "${value.type}" to an array`);
						}
					}else{
						this.error(prop.operator, "Cannot add to a non-array property");
					}
				}
			}
		}
	}
	
	generate() {
		// Setup necessary module files (we write the same files multiple times when there are multiple .shadeup files provided in the cli input)

		this.output({
			context: this.data,
			template: "Plugin/Source/Module/Private/ModuleTemplate.cpp",
			output: `Source/${this.file.module}/Private/${this.file.module}.cpp`,
			data: this
		});

		this.output({
			context: this.data,
			template: "Plugin/Source/Module/Public/ModuleTemplate.h",
			output: `Source/${this.file.module}/Public/${this.file.module}.h`,
			data: this
		});
	}
}

module.exports = BaseGenerator;